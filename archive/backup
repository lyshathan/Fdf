int	set_point(char *s, int index, int y, t_point *parse)
{
	parse[index].x = index;
	parse[index].y = y;


}

int	set_z(int **z, char *s)
{
	*z = malloc(sizeof(int));
	if (!z)
		return (0);
	**z = ft_atoi(s);
	return (1);
}

t_point *ft_parse_line(int fd, int y)
{
	char	*line;
	char	**split;
	int		i;
	t_point	*parse_line;

	line = get_next_line(fd);
	split = ft_split_set(line, " \n");
	if (!split)
		return (NULL);
	i = 0;
	while (split[i])
		i++;
	parse_line = ft_calloc((i + 1), sizeof(t_point));
	if (!parse_line)
		return (NULL);
	i = 0;
	while (split[i])
	{
		parse_line[i].x = i;
		parse_line[i].y = y;
		if (!set_z(&(parse_line[i].z), split[i]))
			return (NULL);
		i++;
	}
	return (parse_line);
}

t_point point_a;
	t_point point_b;
	point_a.x = 0;
	point_a.y = 0;
	point_a.z = malloc(sizeof(int));
	*point_a.z = 5;
	point_b.x = 20;
	point_b.y = 10;
	point_b.z = malloc(sizeof(int));
	*point_b.z = 5;
	draw_line(mlx, mlx_win, 0, point_a, point_b);

	// void	draw_line(void *mlx, void *mlx_win, int shift, t_point point_a, t_point point_b)
// {
// 	float	 x;
// 	float	y;
// 	float	dx;
// 	float	dy;
// 	int	step;

// 	dx = ft_abs(iso_x(point_b)) - ft_abs(iso_x(point_a));
// 	dy = ft_abs(iso_y(point_b)) - ft_abs(iso_y(point_a));
// 	ft_printf("==> dx = %f | dy = %f\n",dx, dy);

// 	if (dx >= dy)
// 		step = dx;
// 	else
// 		step = dy;

// 	dx = dx / step;
// 	dy = dy / step;
// 	ft_printf("step = %d | dx = %f | dy = %f\n", step, dx, dy);

// 	x = iso_x(point_a);
// 	y = iso_y(point_a);

// 	// (void)shift;
// 	// (void)mlx;
// 	// (void)mlx_win;
// 	while (step > 0)
// 	{
// 		mlx_pixel_put(mlx, mlx_win, (x * 20 + shift), (y * 20 + shift), 0x0FF00FF);
// 		x = x + dx;
// 		y = y + dy;
// 		step--;
// 	}
// }


void	print_square(t_setup setup, int x, int y, int size, int color)
{
	int	sq_x;
	int	sq_y;

	sq_y = 0;
	while (sq_y < size)
	{
		sq_x = 0;
		while (sq_x < size)
		{
			mlx_pixel_put(setup.mlx, setup.mlx_win, (sq_x + x), (sq_y + y), color);
			sq_x++;
		}
		sq_y++;
	}

}

void put_pixel_to_image(t_img *img, int x, int y, int color)
{
    char *dst;

    // Ensure the pixel coordinates are within the image bounds
    if (x >= 0 && x < img->width && y >= 0 && y < img->height)
    {
        // Calculate the position of the pixel in the image data
        dst = img->data + (y * img->size_line + x * (img->bpp / 8));
		*(unsigned int*)dst = color;

        // // Set the pixel color
        // if (img->endian == 0)
        // {
        //     dst[0] = (color >> 0) & 0xFF;    // Blue
        //     dst[1] = (color >> 8) & 0xFF;    // Green
        //     dst[2] = (color >> 16) & 0xFF;   // Red
        //     if (img->bpp == 32)
        //         dst[3] = (color >> 24) & 0xFF; // Alpha
        // }
        // else
        // {
        //     dst[0] = (color >> 24) & 0xFF;   // Alpha
        //     dst[1] = (color >> 16) & 0xFF;   // Red
        //     dst[2] = (color >> 8) & 0xFF;    // Green
        //     dst[3] = (color >> 0) & 0xFF;    // Blue
        // }
    }
}

void	aff_map(t_setup stp, t_point **map)
{
	int	x;
	int	y;
	int	col;

	y = 0;
	while (map[y])
	{
		x = 0;
		while (map[y][x].z)
		{
			if (*(map[y][x].z) > 0)
				col = 0x00FF0000;
			else
				col = 0x0000FFFF;
			mlx_pixel_put(stp.mlx, stp.win,
				(map[y][x].x * stp.scale + stp.shift_x),
				(map[y][x].y * stp.scale + stp.shift_y), col);
			x++;
		}
		y++;
	}
}
